/*
**
** WARNING: PKCS #1 v1.5 padding should NOT be used in new applications. It's demonstrated here
**          for the puposes of its use in legacy applications. New applications should use the
**          EME-OAEP padding which is specified in PKCS1 #1 v2.0. An example on how EME-OAEP padding 
**          can be used is contained in the rsa_oaep.c file.
**
**          Also, RSA should not be used as a general purpose encryption algorithm. That is, it should
**          not be used when encrypting messages where symmetric algorithms can be easily substituted. 
**
**          There are serveral reasons for this:
**
**          1) It is extremely slow (when compared to symmetric algorithms).
**          2) Depending on the padding mechanism chosen, it can only encrypt:
**                  # Up to 'n' bytes when the no padding scheme is used
**                  # Up to n - 11 bytes when PKCS #1 v1.5 padding scheme is used
**                  # Up to n - (2*h + 2) bytes when the EME-OAEP padding scheme is used.
**                    
**                  Where 'n' is the length of the modulus (in bytes) and 'h' is the length 
**                  of the hash function's output (in bytes).
**
**          Hence, RSA encryption should only be used for the purposes of: signing and wrapping keys.
**          
**          What is demonstrated in this example is purely for the purposes of exemplifying the concepts 
**          involved in RSA encryption/decryption. So please, do not use it where a symmetric cipher will suffice.
**
*/



#include <stdio.h>

#include <openssl/crypto.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/bn.h>
#include <openssl/rsa.h>
#include <openssl/bio.h>


/* For gaining entropy information on Windows*/
#ifdef _WIN32
#include <Wincrypt.h>
#endif

#define SEED_SIZE   20



/* 
   NOTE: In this example, we're manually assigning the parameter values for the RSA keypairs.
         This is purely for the purposes of demonstrating the capabilities of the OpenSSL API.
         Please generate your own keypair for your purposes.
*/


void set_public_key(RSA* public_key)
{

    unsigned char e[] = "\x01\x00\x01";

    unsigned char n[] =
        "\xF3\xB0\xC7\x39\xF3\x68\x2F\xA5\xB6\xA1\x6D\x5F\xF2\x4F\x89\x52"
        "\x88\x7C\x09\x71\xA4\xE1\x98\xC3\xB8\xF6\x46\x47\x0E\x7C\x71\x44"
        "\x2C\x08\x50\x22\xDC\x87\x9C\xCD\xF5\x30\x59\x03\x9D\x69\xFC\x85"
        "\x33\x8F\xB1\x4A\xD8\x95\x97\x7C\xA4\x61\xC9\x29\xFE\x42\xC7\x60"
        "\x46\xDA\x46\x5C\x56\x62\x94\xBD\x4C\x57\x7E\x90\x35\xFE\x03\x8A"
        "\xE8\x77\xB4\xF2\x62\xCE\xA3\xBB\x6C\x4D\xBF\xFA\xF3\x13\x47\x3C"
        "\x76\xA1\x84\xCE\xBF\x04\xF7\x63\x58\xB8\xC7\xED\x94\x34\xDD\xA7"
        "\x07\x4A\x1D\xF1\x8E\xB2\x31\x01\xBD\x22\x6F\x81\x6D\xFE\xE9\xAA"
        "\xD9\xC2\x1E\x15\x9E\xFB\x98\xFB\x0D\x08\x31\xD8\x06\x1C\x85\xB9"
        "\xFE\x3C\x37\x42\x9C\xA1\x02\xB4\xFA\x67\x9B\x9C\x39\x30\x98\xD7"
        "\x5A\xF4\x48\x4B\xAD\xF6\xDB\xAB\xF0\x08\xE7\x2F\x18\x58\x22\x77"
        "\x94\x30\x1D\xC0\xCE\x2D\x99\x0C\x34\x43\x03\xA0\x1D\x96\x87\x28"
        "\x9A\xFA\x8F\x88\x59\xC3\x84\xFC\x79\x68\xA0\xA1\x80\x53\x54\x3C"
        "\x74\xB4\x7A\x3E\x82\xB0\xAD\xF4\xAD\x7A\x1A\xEF\x12\x30\x3A\x98"
        "\xB8\x02\x58\xA4\x52\x6D\x70\xB3\x06\xAF\xAD\x54\x3A\x64\xF9\x62"
        "\x63\xB4\x5C\x1D\xC9\x24\x39\x21\x67\xB6\xB0\x39\x61\xAF\x98\xA5";


    public_key -> n = BN_bin2bn(n, sizeof(n) - 1, public_key -> n);
    public_key -> e = BN_bin2bn(e, sizeof(e) - 1, public_key -> e);
}


void set_private_key(RSA* private_key)
{
    static unsigned char n[] =
        "\xF3\xB0\xC7\x39\xF3\x68\x2F\xA5\xB6\xA1\x6D\x5F\xF2\x4F\x89\x52"
        "\x88\x7C\x09\x71\xA4\xE1\x98\xC3\xB8\xF6\x46\x47\x0E\x7C\x71\x44"
        "\x2C\x08\x50\x22\xDC\x87\x9C\xCD\xF5\x30\x59\x03\x9D\x69\xFC\x85"
        "\x33\x8F\xB1\x4A\xD8\x95\x97\x7C\xA4\x61\xC9\x29\xFE\x42\xC7\x60"
        "\x46\xDA\x46\x5C\x56\x62\x94\xBD\x4C\x57\x7E\x90\x35\xFE\x03\x8A"
        "\xE8\x77\xB4\xF2\x62\xCE\xA3\xBB\x6C\x4D\xBF\xFA\xF3\x13\x47\x3C"
        "\x76\xA1\x84\xCE\xBF\x04\xF7\x63\x58\xB8\xC7\xED\x94\x34\xDD\xA7"
        "\x07\x4A\x1D\xF1\x8E\xB2\x31\x01\xBD\x22\x6F\x81\x6D\xFE\xE9\xAA"
        "\xD9\xC2\x1E\x15\x9E\xFB\x98\xFB\x0D\x08\x31\xD8\x06\x1C\x85\xB9"
        "\xFE\x3C\x37\x42\x9C\xA1\x02\xB4\xFA\x67\x9B\x9C\x39\x30\x98\xD7"
        "\x5A\xF4\x48\x4B\xAD\xF6\xDB\xAB\xF0\x08\xE7\x2F\x18\x58\x22\x77"
        "\x94\x30\x1D\xC0\xCE\x2D\x99\x0C\x34\x43\x03\xA0\x1D\x96\x87\x28"
        "\x9A\xFA\x8F\x88\x59\xC3\x84\xFC\x79\x68\xA0\xA1\x80\x53\x54\x3C"
        "\x74\xB4\x7A\x3E\x82\xB0\xAD\xF4\xAD\x7A\x1A\xEF\x12\x30\x3A\x98"
        "\xB8\x02\x58\xA4\x52\x6D\x70\xB3\x06\xAF\xAD\x54\x3A\x64\xF9\x62"
        "\x63\xB4\x5C\x1D\xC9\x24\x39\x21\x67\xB6\xB0\x39\x61\xAF\x98\xA5";

    static unsigned char d[] =
        "\x71\x66\x24\xFF\x79\x9E\x54\xF5\xD7\x4B\xBD\x5A\xF5\xA6\x3F\x6F"
        "\xD1\xA5\x6E\xBB\x9C\x8F\x82\x88\x29\xAD\x28\xBC\xEE\x27\xC8\x89"
        "\x81\xB8\x08\x9A\x80\x66\xF6\xF7\xFC\x8E\x18\x0E\x0F\x95\x7F\x75"
        "\xF8\xAD\x78\x42\x2D\x11\x47\xA2\x2F\xD8\x75\x44\xFE\x55\xD2\xF3"
        "\xA1\x64\xF7\x73\x06\x9B\xEF\x3D\x3B\xA6\x47\x76\x12\x39\xF7\x2A"
        "\x0F\xCD\x8C\xBD\x72\x6F\x58\x4F\xE2\x31\x38\x12\x2E\x45\x1D\x54"
        "\x2C\x9C\x32\xF2\x06\x7F\xE8\x23\x29\xE9\x2A\xD8\x0A\xAC\xA3\x2C"
        "\x93\xBE\xD0\xBA\x54\xBD\xE5\x02\x3B\x22\x28\x23\x61\xAD\x4A\xCC"
        "\x56\xEB\x7A\xAE\x85\x0B\xF0\x62\x31\x77\x51\xC4\x2A\x1F\xA3\xD8"
        "\x02\xC7\x9B\xDB\x4E\xFC\x81\xE2\x6A\xBA\x38\x36\x02\x73\x4D\xA7"
        "\xEE\xDF\x14\x7A\xD9\xD8\xDF\x15\xD0\xC2\x40\x92\xF2\x88\xB6\x12"
        "\x1F\xB3\x14\xC0\xCA\xEB\x38\x7D\x73\xEB\x04\x7E\xE7\xE6\xC1\xF0"
        "\xDF\x7B\xD1\x4E\x92\xA5\x0F\x21\xB9\xC5\xF6\xC9\x6E\x9D\xE6\xFD"
        "\xE5\xB2\x77\x9E\x1E\x86\x3C\x4B\x63\xA1\x0D\x05\x8D\x31\x9C\x1B"
        "\x51\xBF\x41\xB4\x6A\x98\x54\xCA\x35\x78\x8B\xA8\x5E\xF8\x64\x08"
        "\xE6\x7D\x3A\x5D\x0C\x14\x8B\x41\x35\xF8\x34\xC8\x61\x4A\xC5\xE1";

    static unsigned char p[] =
        "\xFF\xFB\x74\xD4\xAC\xAA\xAE\x06\xF4\xF3\x7E\x31\x1D\x1D\xE9\x87"
        "\x72\x6B\x46\x8A\x06\xA9\x15\x8D\xB5\x38\x86\x59\x40\xB7\x60\xB3"
        "\xD2\x43\xDE\x74\xDC\xD1\x7F\x64\xF3\xE8\x09\x1B\xF8\x9D\xA2\x74"
        "\xA7\xC2\x07\x00\x69\x07\xE0\xC8\x55\x74\x82\x2E\x34\xE3\x09\xEB"
        "\x24\xA2\xF8\x6E\x13\xBE\x50\xE5\x07\x48\xAF\xD2\x21\x03\x20\xD9"
        "\x71\x34\xFE\x49\x93\x52\x58\xFC\x65\xAB\xD2\x83\xF5\xD3\x27\x92"
        "\xEE\xA4\x9D\xDC\x18\xCA\x24\x78\x86\x94\xA4\x10\xC6\x62\x84\x19"
        "\x1F\xC5\xF0\x58\x88\x63\x72\xD7\x69\xA1\x9E\x9F\x35\x08\x51\x09";

    static unsigned char q[] =
        "\xF3\xB5\x1A\x8A\xF1\xBD\xCD\xFB\xD7\xDE\x6A\x01\x48\xA3\xF8\x17"
        "\xA9\x98\x05\x97\x02\x93\x36\x89\x67\x0A\x82\x7E\x8A\x07\x0A\x20"
        "\xB9\xCF\xF0\x79\xB2\x55\x39\xA3\x03\x36\x6B\xD1\x92\x7B\x24\xB7"
        "\x7C\x77\x2F\x38\xCE\x24\x8A\x89\x2F\xD0\xD8\x1B\xA7\x90\x7E\xAD"
        "\xB9\x41\x65\xC6\x4E\x59\xBC\x52\xEF\xD0\x93\x98\xC5\xC9\xA6\xFC"
        "\x65\x76\xE4\xEC\x13\xF0\x78\x20\xD1\x2A\x78\xBF\x5E\xE3\x04\xE5"
        "\x49\x03\x4F\xA8\x3F\xB5\x84\xBB\xF4\x62\x94\x57\x26\x34\x83\x5C"
        "\x66\x5F\x37\x4B\xAE\xF4\xD7\x66\x0B\x55\x56\x5C\xF8\x9F\xDD\xBD";

    static unsigned char dmp1[] =
        "\x1E\xC8\x55\x57\x51\xE0\x40\x87\x33\xA3\xA8\x54\x2D\xA5\x30\x35"
        "\x0A\x8C\x5D\xF2\x31\x34\xDA\x13\xAD\x6C\x3B\xB3\xB5\xF5\x97\x5A"
        "\x68\x79\xA2\xE1\xB8\xC0\x34\xAA\xA6\x2E\x0C\x12\x62\x06\x4A\xC7"
        "\xEE\x78\x85\xB1\x05\xF0\x5D\x96\x99\xB8\x26\x03\x7A\x76\xA6\xF5"
        "\xB0\xF5\x2C\x1C\xC8\xA1\x05\x47\x55\x65\xE7\x46\xC4\x93\x84\xBA"
        "\xC1\x43\x57\x24\xEF\xE3\x62\x32\x0F\xE3\xE6\xAF\xD9\xBA\xE7\xB2"
        "\x62\xA2\x47\x1D\x75\x99\xB1\x63\x11\x04\x04\xEA\xC3\x80\x8B\x54"
        "\x1E\x1F\x06\x75\x0F\x09\xAE\x80\xBB\x02\x25\x7A\x0D\xBD\x8F\x49";

    static unsigned char dmq1[] =
        "\x19\x87\x42\x05\x85\xF7\x1C\xE9\xA1\x9E\x31\xBA\x7A\xB2\x7A\x5D"
        "\x78\x2D\x6D\x80\x79\x0B\x94\xAD\xE5\xF6\x4A\xDF\x18\x74\x4E\x52"
        "\x49\x44\x87\xEB\x27\x8C\x17\xE2\x84\x86\xA1\xDA\xAD\x1E\x6B\x25"
        "\x31\x4B\x86\xCD\xCB\x82\x36\x64\xD2\x76\x6C\xFC\xD0\x9B\xA9\x39"
        "\x67\x6B\x7B\x4E\xBF\x8C\x54\xD6\xD7\x3A\x21\x0B\xE2\xC4\x11\xD2"
        "\xE4\x8A\x04\xC6\xD9\xFB\xD9\x89\x8E\x7F\x85\x70\x7E\x6F\x07\x67"
        "\x41\x33\xB0\x97\x6E\x3D\x04\x6F\x6F\xD5\x17\xB6\xDD\x50\xA8\xE5"
        "\xF7\xEF\x47\x6A\x8D\x24\x26\xA0\x10\xD5\xDA\x9B\x18\x8C\x1E\x7D";

    static unsigned char iqmp[] =
        "\x29\xCA\xDD\xE7\x07\xD4\xA7\xD8\xC7\xB1\x15\xEB\x13\xB4\x6F\x34"
        "\x1D\xEA\x7A\x43\x4D\x86\xB5\xB8\x87\x50\x51\x05\xD9\xA8\x17\x10"
        "\xB4\xD2\x4A\x97\xB7\x28\x80\x34\xE4\xD9\x8E\xB2\x08\xEB\x7C\x0D"
        "\xC3\x65\xB1\xE5\x89\x8F\x26\x5F\x7E\x49\x12\x0D\xBD\x4E\x51\x03"
        "\x7A\x5C\xCF\x1B\xBB\xAF\x79\x0E\x59\xAA\x4C\x12\x9D\x0A\x00\xF5"
        "\x06\x61\x82\xB5\x9D\x5B\x71\xC5\xAE\xE6\x1C\xB9\xFD\xA7\xAE\x9A"
        "\x34\x2A\x35\xF0\x0A\x0D\xD5\xC9\xB3\xC4\x95\x50\x5C\x04\xF6\x3D"
        "\x5E\x58\x91\xDF\xA4\x91\x20\x3E\x71\x39\x88\x9F\x4A\xF2\xD3\xC9";

 
    /* Set the values pertaining to the private key */
    /* Note: The values for p, q, dmp1, dmq1 and iqmp are not necessary.
             However, if these values are provided, decryption can be carried
             out quickly. For more information, see:
             http://en.wikipedia.org/wiki/RSA_(algorithm)#Using_the_Chinese_remainder_algorithm
     */

    private_key -> n = BN_bin2bn(n, sizeof(n) - 1, private_key -> n);
    private_key -> d = BN_bin2bn(d, sizeof(d) - 1, private_key -> d);

    private_key -> p = BN_bin2bn(p, sizeof(p) - 1, private_key -> p);
    private_key -> q = BN_bin2bn(q, sizeof(q) - 1, private_key -> q);
    private_key -> dmp1 = BN_bin2bn(dmp1, sizeof(dmp1) - 1, private_key -> dmp1);
    private_key -> dmq1 = BN_bin2bn(dmq1, sizeof(dmq1) - 1, private_key -> dmq1);
    private_key -> iqmp = BN_bin2bn(iqmp, sizeof(iqmp) - 1, private_key -> iqmp);

}


/* For Windows environments */
#ifdef _WIN32

void generate_seed(unsigned char* seed, int length)
{
    HCRYPTPROV providerHandle;

    if (!CryptAcquireContext(&providerHandle, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
    {
        fprintf(stderr, "A cryptographic service handle could not be acquired\n");
        exit(1);
    }

    if (!CryptGenRandom(providerHandle, length, seed))
    {
        fprintf(stderr, "Error during CryptGenRandom\n");
        CryptReleaseContext(providerHandle, 0);
        exit(1);
    }
    
}

#else

/* For all other *nix environments */
void generate_seed(unsigned char* seed, int length)
{


}

#endif



int main(void)
{
    int     i;
	BIO*    bio_out;

    RSA*    public_key;
    RSA*    private_key;

    int     ciphertext_len      = 0;
    int     plaintext_len       = 0;
    unsigned char*  ciphertext  = NULL;
    unsigned char*  plaintext   = NULL;


    unsigned char   seed_data[SEED_SIZE];

    /* The data to encrypt. The data, in ASCII form is: "Test Data!" */
    unsigned char data[]  = "\x54\x65\x73\x74\x20\x44\x61\x74\x61\x21";

    /* Length of the above data. For PKCS #1 v1.5, this length must be 11 bytes less than the size of the modulus */
    int data_length       = sizeof(data) - 1;

    /* Set-up the public key */
    public_key = RSA_new();
    set_public_key(public_key);

    /* Retrieve the ciphertext length (i.e. size of the modulus) */
    ciphertext_len  = RSA_size(public_key);

    /* Allocate the required amount of memory for the ciphertext. */
    ciphertext      = (unsigned char*) calloc(ciphertext_len, sizeof(unsigned char));    

    /* Seed the random number generator. */
    generate_seed(seed_data, SEED_SIZE);
    
    /* Carry out the encryption */
    if ((ciphertext_len = RSA_public_encrypt(data_length, data, ciphertext, public_key, RSA_PKCS1_PADDING)) == -1)
    {        
        fprintf(stderr, "Error carrying out encryption. Error code: %lu\n", ERR_get_error());
        exit(1);
    }

    /* Setup output */
    bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);

    BIO_printf(bio_out, "Original plaintext: %s\n\n", data);
    BIO_printf(bio_out, "Ciphertext: ");


    /* Print out the ciphertext */
    for (i = 0; i < ciphertext_len; i++)
        BIO_printf(bio_out, "%02x", ((unsigned char*)ciphertext)[i]);

    BIO_printf(bio_out, "\n\n");



    /* Start the decryption process */

    /* Set up the private key */
    private_key = RSA_new();
    set_private_key(private_key);

    /* Allocate the same amount of memory (as for the ciphertext) for the plaintext. */
    plaintext   = (unsigned char*) calloc(ciphertext_len, sizeof(unsigned char)); 

    /* Now, carry out the decryption */ 
    if ((plaintext_len = RSA_private_decrypt(ciphertext_len, ciphertext, plaintext, private_key, RSA_PKCS1_PADDING)) == -1)
    {
        fprintf(stderr, "Error carrying out the decryption. Error code: %lu\n", ERR_get_error());
        exit(1);
    }
        
    BIO_printf(bio_out, "Recovered plaintext: ");    

    /* Print out the plaintext. Note: We use the length returned by RSA_private_decrypt */
    for (i = 0; i < plaintext_len; i++)
        BIO_printf(bio_out, "%c", ((unsigned char*)plaintext)[i]);

    BIO_printf(bio_out, "\n\n");

    free(ciphertext);
    free(plaintext);

    BIO_free(bio_out);
    RSA_free(public_key);
    RSA_free(private_key);

    return 0;
}


